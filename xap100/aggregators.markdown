---
layout: post100
title:  Aggregators
categories: XAP100
weight: 550
parent: the-gigaspace-interface-overview.html
---

{% summary  %}  {% endsummary %}

{%section%}
{%column width=60% %}
With many systems such as pricing systems, risk management, trading and other analytic and business intelligence applications you may need to perform an aggregation activity across data stored within the data grid when generating reports or when running some business process. Such activity can leverage data stored in memory and will be much faster than performing it with a database.
{%endcolumn%}
{%column width=40% %}
![aggreg.jpg](/attachment_files/built-in-aggregators.jpg)
{%endcolumn%}
{%endsection%}

XAP provides common functionality to perform aggregations across the space. There is no need to retrieve the entire data set from the space to the client side , iterate the result set and perform the aggregation. This would be an expensive activity as it might return large amount of data into the client application. 


Built-in Aggregators allow you to perform the entire aggregation activity at the space side avoiding any data retrieval back to the client side. Only the result of each aggregation activity performed with each partition is returned back to the client side where all the results are reduced and returned to the client application. Such aggregation activity utilize the partitioned nature of the data-grid allowing each partition to execute the aggregation with its local data in parallel, where all the partitions intermediate results are fully aggregated at the client side using the relevant reducer implementation.


## How Aggregators Works?

Aggregators are executed by iterating the internal data grid structure that maintains the space objects. There is no materialization of the original user data grid object when performing this iteration (scan). This allows relatively fast scan. There is no need to index the aggregated fields (paths) - only the fields (paths) used to execute the query used to generate the result set scanned to calculate the aggregation. Future XAP releases may use indexes to perform the aggregation. 


# Supported Aggregators

XAP comes with several built-in Aggregators you may use. The aggregation process executed across all data grid partitions when using a partitioned data grid , or across the proxy master replica when using a replicated data grid. You may rout the aggregation into a specific partition. You may implement also a custom Aggregator that will perform a special aggregation logic on a given field (path) and a given entries set based on a query. Aggregators are specified via the `com.gigaspaces.query.aggregators.AggregationSet` that may have one or more Aggregators listed. 


{: .table .table-bordered}
| Name | Description |
|:-----|:------------|
|Min| Returns the minimum value for a set of data grid entries for a given field (path) based on a given query.|
|Max| Returns the maximum value for a set of data grid entries for a given field (path) based on a given query.|
|Count| Returns the count (matching entries) value for a set of data grid entries based on a given query.|
|Average| Returns the average value for a given set of data grid entries for a given field (path) based on a given query.|
|Sum|Returns the sum value for a set of data grid entries for a given field (path) based on a given query.|
|GroupBy| Returns a key/value map of generated result set for multiple aggregations based on a given query and a given field(s)/paths(s). Perform similar aggregation as the SQL GROUP BY Statement|
|Having|Used to perform additional filtering on the aggregation result set. Perform similar aggregation as the SQL `HAVING` Clause|
|maxEntry| Returns the Entry (space object) with the maximum value for a set of data grid entries for a given field (path) based on a given query.|
|minEntry| Returns the Entry (space object) with the minimum value for a set of data grid entries for a given field (path) based on a given query.|
|Custom| An extention to the `com.gigaspaces.query.aggregators.SpaceEntriesAggregator'. Return the aggregation for a user defined logic on a given field (path) and a given entries set based on a query.|


# Interoperability 

Aggregators may be performed on any data generated by any type of client. For example - A call for Aggregation from a Java application may be performed on space objects that were written into the space using .Net application using the XAP.Net API or C++ application using the XAP C++ API. Same for a call from .Net Aggregation API for data written into the space via a Java application.


# Usage

Here are some aggregation examples using the [QueryExtension](http://www.gigaspaces.com/docs/JavaDoc{%currentversion%}/index.html?org/openspaces/extensions/QueryExtension.html)

{% inittab %}
{% tabcontent Application %}
{% highlight java %}
import static org.openspaces.extensions.QueryExtension.*;
...
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class,"country=? OR country=? ");
query.setParameter(1, "UK");
query.setParameter(2, "U.S.A");

// retrieve the maximum value stored in the field "age"
Number maxAgeInSpace = max(space, personSQLQuery, "age");
/// retrieve the minimum value stored in the field "age"
Number minAgeInSpace = min(space, personSQLQuery, "age");
// Sum the "age" field on all space objects.
Number combinedAgeInSpace = sum(space, personSQLQuery, "age");
// Sum's the "age" field on all space objects then divides by the number of space objects.
Double averageAge = average(space, personSQLQuery, "age");
// Retrieve the space object with the highest value for the field "age".
Person oldestPersonInSpace = maxEntry(space, personSQLQuery, "age");
/// Retrieve the space object with the lowest value for the field "age".
Person youngestPersonInSpace = minEntry(space, personSQLQuery, "age");
{% endhighlight %}
{% endtabcontent%}
{% tabcontent Space Class %}
{% highlight java %}
@SpaceClass
public class Person {
    private Long id;
    private Long age;
    private String country;

    @SpaceId(autoGenerate=false)
    public Long getId() {
        return id;
    }

    public Person setId(Long id) {
        this.id = id;
        return this;
    }

    public Long getAge() {
        return age;
    }

    public Person setAge(Long age) {
        this.age = age;
        return this;
    }

    @SpaceIndex
    public String getCountry() {
        return country;
    }

    public Person setCountry(String country) {
        this.country = country;
        return this;
    }
}
{% endhighlight %}
{% endtabcontent%}
{%endinittab%}

# Compound Aggregation

{%section%}
{%column width=60% %}
Compound aggregation will execute multiple aggregation operations across the space returning all of the result sets at once. When multiple aggregates are needed the compound aggregation API is significantly faster than calling each individual aggregate.

{%endcolumn%}
{%column width=40% %}
![aggreg.jpg](/attachment_files/built-in-Compound-aggregators.jpg)
{%endcolumn%}
{%endsection%}


{% highlight java %}
import static org.openspaces.extensions.QueryExtension.*;
...
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class,"country=? OR country=? ");
query.setParameter(1, "UK");
query.setParameter(2, "U.S.A");

AggregationResult aggregationResult = space.aggregate(query,
		new AggregationSet().maxEntry("age").minEntry("age").sum("age")
			.average("age").minValue("age").maxValue("age"));

Person oldest = (Person) aggregationResult.get(0);
Person youngest = (Person) aggregationResult.get(1);
Number sum = (Number) aggregationResult.get(2);
Double average = (Double) aggregationResult.get(3);
Number min = (Number) aggregationResult.get(4);
Number max = (Number) aggregationResult.get(5);
{% endhighlight %}

# Nested Fields Aggregation

Aggregation against the members of embedded space classes (nested field) is supported by supplying the field path while invoking the desired aggregate function.

{% inittab %}
{% tabcontent Application %}
{% highlight java %}
import static org.openspaces.extensions.QueryExtension.*;
...
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class,"country=? OR country=? ");
query.setParameter(1, "UK");
query.setParameter(2, "U.S.A");

// retrieve the maximum value stored in the field "age"
Number maxAgeInSpace = max(space, personSQLQuery, "demographics.age");
{% endhighlight %}
{% endtabcontent %}
{% tabcontent Person Space Class %}
{% highlight java %}
@SpaceClass
public class Person {
    private String id;
    private String name;
    private String state;
    private Demographics demographics;

    @SpaceId(autoGenerate = true)
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public Demographics getDemographics() {
        return demographics;
    }

    public void setDemographics(Demographics demographics) {
        this.demographics = demographics;
    }
}
{% endhighlight %}
{% endtabcontent %}
{% tabcontent Demographic Space Class %}
{% highlight java %}
public class Demographics     {
    private Integer age;
    private char gender;

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public char getGender() {
        return gender;
    }

    public void setGender(char gender) {
        this.gender = gender;
    }
}
{% endhighlight %}
{% endtabcontent %}
{% endinittab %}


# Group Aggregation


The [GroupByAggregator](http://www.gigaspaces.com/docs//JavaDoc{%currentversion%}/index.html?com/gigaspaces/query/aggregators/GroupByAggregator.html) is used in conjunction with the aggregate functions to group the result-set by one or more columns. Here is an example:


{%highlight java%}
import static org.openspaces.extensions.QueryExtension.*;
import com.gigaspaces.query.aggregators.GroupByAggregator;
import com.gigaspaces.query.aggregators.GroupByFilter;
import com.gigaspaces.query.aggregators.GroupByResult;
import com.gigaspaces.query.aggregators.GroupByValue;

// select AVG(salary), MIN(salary), MAX(salary) from Employees WHERE age > 50 group by Department, Gender
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class, "age > ?",50);
GroupByResult groupByResult = groupBy(gigaSpace, query, new GroupByAggregator()
				.select(average("salary"), min("salary"), max("salary"))
				.groupBy("department", "gender"));

for (GroupByValue group : groupByResult) {
    // Getting info from the keys:
    Department department = (Department) group.getKey().get("department");
	Gender gender = (Gender) group.getKey().get("gender");
	// Getting info from the value:
	double avgSalary = group.getDouble("avg(salary)");
	long maxSalary = group.getLong("max(salary)");
	long minSalary = group.getLong("min(salary)");
}
{%endhighlight%}


You can also use the [GroupByFilter](http://www.gigaspaces.com/docs/JavaDoc{%currentversion%}/index.html?com/gigaspaces/query/aggregators/GroupByFilter.html) to restrict the groups of selected objects to only those whose condition is TRUE simialr to the SQL `HAVING` Clause.

{%highlight java%}
// Select AVG(Salary) , Count(*) from Employees Where companyId = 10 group by Department Having AVG(Salary) > 18,000
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class,"companyId = 10");

GroupByResult groupByResult = groupBy(gigaSpace, query, new GroupByAggregator()
		.select(average("salary"), count()).groupBy("department")
		.having(new GroupByFilter() {
			@Override
			public boolean process(GroupByValue group) {
				return group.getDouble("avg(salary)") > 18000;
			}
        }));

for (GroupByValue group : groupByResult) {
    // Getting info from the keys:
    Department department = (Department) group.getKey().get("department");
    // Getting info from the value:
	double avgSalary = group.getDouble("avg(salary)");
	long count = group.getLong("count(*)");
}
{%endhighlight%}


# Routing

When running on a partitioned space, it is important to understand how routing is determined for SQL queries.
If the routing property is part of the criteria expression with an equality operand and without ORs, its value is used for routing.
In some scenarios we may want to execute the query on a specific partition without matching the routing property (e.g. blocking operation). This can be done via the `setRouting` method:

{%highlight java%}
// Select AVG(Salary) , Count(*) from Employees Where companyId = 10 group by Department Having AVG(Salary) > 18,000
SQLQuery<Employee> query = new SQLQuery<Employee>(Employee.class,"companyId = 10");
query.setRouting(1);

GroupByResult groupByResult = groupBy(gigaSpace, query, new GroupByAggregator()
		.select(average("salary"), count()).groupBy("department")
		.having(new GroupByFilter() {
			@Override
			public boolean process(GroupByValue group) {
				return group.getDouble("avg(salary)") > 18000;
			}
        }));

for (GroupByValue group : groupByResult) {
    // Getting info from the keys:
    Department department = (Department) group.getKey().get("department");
    // Getting info from the value:
	double avgSalary = group.getDouble("avg(salary)");
	long count = group.getLong("count(*)");
}

{%endhighlight%}


{%learn%}./query-sql.html#routing{%endlearn%}

# Custom Aggregation


You may extend the `com.gigaspaces.query.aggregators.SpaceEntriesAggregator' to execute user defined aggregation logic on a given field (path) and a given entries set based on a query.

Below example of a `String` field concatenation aggregator - for each entry extracts the field (path) value and concatenates with the previous values extratced.

Executing the Aggregation logic:

{%highlight java%}
AggregationResult result = gigaSpace.aggregate(query, new AggregationSet().add(new ConcatAggregator("name")));
String concatResult = result.getString("concat(name)");
System.out.println(concatResult);
{%endhighlight%}

The `ConcatAggregator` Aggregation logic extending the `SpaceEntriesAggregator`:

{%highlight java%}
import com.gigaspaces.query.aggregators.SpaceEntriesAggregator;
import com.gigaspaces.query.aggregators.SpaceEntriesAggregatorContext;

public class ConcatAggregator extends SpaceEntriesAggregator<String> {

    private final String path;
    private transient StringBuilder sb;

    public ConcatAggregator(String path) {
        this.path = path;
    }

    @Override
    public String getDefaultAlias() {
        return "concat(" + path + ")";
    }

    @Override
    public void aggregate(SpaceEntriesAggregatorContext context) {
        String value = (String) context.getPathValue(path);
        if (value != null)
            concat(value);
    }

    @Override
    public String getIntermediateResult() {
        return sb == null ? null : sb.toString();
    }

    @Override
    public void aggregateIntermediateResult(String partitionResult) {
        concat(partitionResult);
    }

    private void concat(String s) {
        if (sb == null) {
            sb = new StringBuilder(s);
        } else {
            sb.append(',').append(s);
        }
    }
}

{%endhighlight%}
